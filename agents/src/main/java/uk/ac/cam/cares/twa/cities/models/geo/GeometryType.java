package uk.ac.cam.cares.twa.cities.models.geo;

import java.util.Arrays;
import java.util.Objects;

import lombok.Getter;
import lombok.Setter;
import org.apache.jena.graph.Node;
import org.apache.jena.graph.NodeFactory;
import org.geotools.referencing.CRS;
import org.geotools.geometry.jts.JTS;
import org.locationtech.jts.geom.*;
import org.locationtech.jts.math.Vector3D;
import org.opengis.referencing.FactoryException;
import org.opengis.referencing.crs.CoordinateReferenceSystem;
import org.opengis.referencing.operation.MathTransform;
import org.opengis.referencing.operation.TransformException;
import uk.ac.cam.cares.jps.base.exception.JPSRuntimeException;
import uk.ac.cam.cares.twa.cities.ArbitraryJenaDatatype;
import uk.ac.cam.cares.twa.cities.DatatypeModel;

public class GeometryType extends DatatypeModel {

  protected static GeometryFactory factory = new GeometryFactory();

  // Set source crs and metric crs before constructing a GeometryType
  @Setter protected static String sourceCrsName = "EPSG:4326";

  // At construction, these are saved and initialised from the static settings.
  protected MathTransform transform = null;
  @Getter protected Coordinate utmAnchor; // EPSG:4326
  @Getter protected CoordinateReferenceSystem sourceCrs;

  // Normal and area are not generated by default
  @Getter Vector3D normal;
  @Getter double area = -1;
  @Getter protected Polygon polygon;
  @Getter private Coordinate centroid;
  @Getter private Polygon metricPolygon;
  @Getter private Coordinate metricCentroid;

  public GeometryType() {

  }

  public GeometryType(String data, String structure) {
    // decode coordinates
    String[] valueStrings = data.split("#");
    double[] values = new double[valueStrings.length];
    for (int i = 0; i < valueStrings.length; i++) values[i] = Double.parseDouble(valueStrings[i]);
    // Deserialize coordinates into rings based on structure string, which should be e.g. [...]POLYGON-3-24-15-15.
    String[] ringSizes = structure.split("-");
    ringSizes = Arrays.copyOfRange(ringSizes, 2, ringSizes.length);
    LinearRing exterior = null;
    LinearRing[] holes = new LinearRing[ringSizes.length - 1];
    int k = 0;
    try {
      for (int i = 0; i < ringSizes.length; i++) {
        int ringSize = Integer.parseInt(ringSizes[i]) / 3;
        Coordinate[] coords = new Coordinate[ringSize];
        for (int j = 0; j < ringSize; j++)
          coords[j] = new Coordinate(values[k++], values[k++], values[k++]);
        if (i == 0) exterior = factory.createLinearRing(coords);
        else holes[i - 1] = factory.createLinearRing(coords);
      }
    } catch (IndexOutOfBoundsException e) {
      throw new JPSRuntimeException(e);
    }
    polygon = factory.createPolygon(exterior, holes);
    recalculateGeometricProperties();
  }

  /**
   * Calculates centroid, metric polygon, metric centroid, normal and area.
   * Call this after polygon is set.
   */
  protected void recalculateGeometricProperties() {
    // Generate transformation to metric
    try {
      // Generate transform
      sourceCrs = CRS.decode(sourceCrsName);
      Coordinate utmAnchorInSourceSrs = polygon.getExteriorRing().getCoordinateN(0);
      CoordinateReferenceSystem epsg4326 = CRS.decode("urn:x-ogc:def:crs:EPSG:4326");
      MathTransform transformToEpsg4326 = CRS.findMathTransform(sourceCrs, epsg4326, true);
      utmAnchor = JTS.transform(utmAnchorInSourceSrs, utmAnchor, transformToEpsg4326);
      // CRS axis order is NORTH_EAST (LAT_LON). UTM center is specified LON_LAT.
      CoordinateReferenceSystem metricCrs = CRS.decode("AUTO:42001,1," + utmAnchor.y + "," + utmAnchor.x);
      transform = CRS.findMathTransform(sourceCrs, metricCrs, true);
      // Calculate properties
      metricPolygon = (Polygon) JTS.transform(polygon, transform);
      metricCentroid = computeCentroid(metricPolygon);
      centroid = JTS.transform(metricCentroid, centroid, transform.inverse());
      centroid.setZ(metricCentroid.getZ());
      Vector3D vectorArea = computeVectorArea((LinearRing) metricPolygon.getExteriorRing());
      normal = vectorArea.normalize();
      area = vectorArea.length();
    } catch (TransformException | FactoryException e) {
      throw new JPSRuntimeException(e);
    }
  }

  public static Coordinate computeCentroid(Polygon polygon) {
    return computeCentroid(polygon.getExteriorRing().getCoordinates(), true);
  }

  public static Coordinate computeCentroid(Coordinate[] coordinates, boolean skipLast) {
    double x = 0;
    double y = 0;
    double z = 0;
    int length = coordinates.length - (skipLast ? 1 : 0);
    for (int i = 0; i < length; i++) {
      x += coordinates[i].getX();
      y += coordinates[i].getY();
      z += coordinates[i].getZ();
    }
    return new Coordinate(x / length, y / length, z / length);
  }

  // Assumes counter-clockwise winding order
  public static Vector3D computeVectorArea(LinearRing ring) {
    CoordinateSequence coords = ring.getCoordinateSequence();
    double x = 0;
    double y = 0;
    double z = 0;
    for (int i = 0; i < coords.size() - 1; i++) {
      x += (coords.getZ(i) + coords.getZ(i + 1)) * (coords.getY(i) - coords.getY(i + 1));
      y += (coords.getX(i) + coords.getX(i + 1)) * (coords.getZ(i) - coords.getZ(i + 1));
      z += (coords.getY(i) + coords.getY(i + 1)) * (coords.getX(i) - coords.getX(i + 1));
    }
    return new Vector3D(x / 2, y / 2, z / 2);
  }

  @Override
  public Node getNode() {
    // Value
    Coordinate[] coordinates = polygon.getCoordinates();
    if (coordinates.length == 0) return NodeFactory.createBlankNode();
    StringBuilder value = new StringBuilder();
    for (Coordinate coordinate : coordinates)
      for (int i = 0; i < 3; i++)
        value.append("#").append(coordinate.getOrdinate(i));
    value.deleteCharAt(0);
    // Datatype
    StringBuilder datatype = new StringBuilder();
    datatype.append("http://localhost/blazegraph/literals/POLYGON-3");
    datatype.append("-" + polygon.getExteriorRing().getNumPoints() * 3);
    for (int i = 0; i < polygon.getNumInteriorRing(); i++)
      datatype.append("-" + polygon.getInteriorRingN(i).getNumPoints() * 3);
    return NodeFactory.createLiteral(value.toString(), ArbitraryJenaDatatype.get(datatype.toString()));
  }

  @Override
  public int hashCode() {
    return Objects.hash(sourceCrs, polygon);
  }

}
