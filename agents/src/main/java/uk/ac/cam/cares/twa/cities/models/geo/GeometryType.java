package uk.ac.cam.cares.twa.cities.models.geo;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Stream;

import lombok.Getter;
import lombok.Setter;
import org.geotools.referencing.CRS;
import org.geotools.geometry.jts.JTS;
import org.locationtech.jts.geom.*;
import org.locationtech.jts.math.Vector3D;
import org.opengis.referencing.FactoryException;
import org.opengis.referencing.crs.CoordinateReferenceSystem;
import org.opengis.referencing.operation.MathTransform;
import org.opengis.referencing.operation.TransformException;
import uk.ac.cam.cares.jps.base.exception.JPSRuntimeException;
import uk.ac.cam.cares.twa.cities.DatatypeModel;

import javax.ws.rs.BadRequestException;

public class GeometryType implements DatatypeModel {

  protected static GeometryFactory factory = new GeometryFactory();

  // Set source crs and metric crs before constructing a GeometryType
  @Setter protected static String sourceCrsName = "EPSG:24500";
  @Setter protected static String metricCrsName = "EPSG:24500";

  // At construction, these are saved and initialised from the static settings.
  protected MathTransform transform = null;
  @Getter protected CoordinateReferenceSystem sourceCrs;
  @Getter protected CoordinateReferenceSystem metricCrs;

  // Normal and area are not generated by default
  @Getter private Vector3D normal;
  @Getter private double area = -1;
  @Getter protected Polygon polygon;
  @Getter private Coordinate centroid;
  @Getter private Polygon metricPolygon;
  @Getter private Coordinate metricCentroid;

  public GeometryType() {
    try {
      sourceCrs = CRS.decode(sourceCrsName);
      metricCrs = CRS.decode(metricCrsName);
      transform = CRS.findMathTransform(sourceCrs, metricCrs, true);
    } catch (FactoryException e) {
      throw new JPSRuntimeException(e);
    }
  }

  public GeometryType(String data, String structure) {
    this();
    // decode coordinates
    String[] valueStrings = data.split("#");
    double[] values = new double[valueStrings.length];
    for (int i = 0; i < valueStrings.length; i++) values[i] = Double.parseDouble(valueStrings[i]);
    // Deserialize coordinates into rings based on structure string, which should be e.g. [...]POLYGON-3-24-15-15.
    String[] ringSizes = structure.split("-");
    ringSizes = Arrays.copyOfRange(ringSizes, 2, ringSizes.length);
    LinearRing exterior = null;
    LinearRing[] holes = new LinearRing[ringSizes.length - 1];
    int k = 0;
    try {
      for (int i = 0; i < ringSizes.length; i++) {
        int ringSize = Integer.parseInt(ringSizes[i]) / 3;
        Coordinate[] coords = new Coordinate[ringSize];
        for (int j = 0; j < ringSize; j++)
          coords[j] = new Coordinate(values[k++], values[k++], values[k++]);
        if (i == 0) exterior = factory.createLinearRing(coords);
        else holes[i - 1] = factory.createLinearRing(coords);
      }
    } catch (IndexOutOfBoundsException e) {
      throw new JPSRuntimeException(e);
    }
    polygon = factory.createPolygon(exterior, holes);
    recalculateGeometricProperties();
  }

  /**
   * Calculates centroid, metric polygon, metric centroid, normal and area.
   * Call this after polygon is set.
   */
  protected void recalculateGeometricProperties() {
    centroid = computeCentroid(polygon);
    try {
      metricPolygon = (Polygon) JTS.transform(polygon, transform);
      metricCentroid = computeCentroid(metricPolygon);
      Vector3D vectorArea = computeVectorArea((LinearRing) metricPolygon.getExteriorRing());
      normal = vectorArea.normalize();
      area = vectorArea.length();
    } catch (TransformException e) {
      throw new JPSRuntimeException(e);
    }
  }

  public static Coordinate computeCentroid(Polygon polygon) {
    return computeCentroid(polygon.getExteriorRing().getCoordinates(), true);
  }

  public static Coordinate computeCentroid(Coordinate[] coordinates, boolean skipLast) {
    double x = 0;
    double y = 0;
    double z = 0;
    for(int i = 0; i < coordinates.length - (skipLast ? 1 : 0); i++) {
      x += coordinates[i].getX();
      y += coordinates[i].getY();
      z += coordinates[i].getZ();
    }
    return new Coordinate(x/coordinates.length, y/coordinates.length, z/coordinates.length);
  }

  public static Vector3D computeVectorArea(LinearRing ring) {
    CoordinateSequence coords = ring.getCoordinateSequence();
    double x = 0;
    double y = 0;
    double z = 0;
    for (int i = 0; i < coords.size() - 1; i++) {
      x += (coords.getZ(i + 1) + coords.getZ(i)) * (coords.getY(i + 1) - coords.getY(i));
      y += (coords.getX(i + 1) + coords.getX(i)) * (coords.getZ(i + 1) - coords.getZ(i));
      z += (coords.getY(i + 1) + coords.getY(i)) * (coords.getX(i + 1) - coords.getX(i));
    }
    return new Vector3D(x, y, z);
  }

  @Override
  public String getLiteralString() {
    // Value
    Coordinate[] coordinates = polygon.getCoordinates();
    if(coordinates.length == 0) return "";
    StringBuilder str = new StringBuilder("\"");
    for(Coordinate coordinate: coordinates)
      for(int i = 0; i < 3; i++)
        str.append("#").append(coordinate.getOrdinate(i));
    str.deleteCharAt(1);
    // Datatype
    str.append("\"^^<http://localhost/blazegraph/literals/POLYGON-3");
    str.append("-" + polygon.getExteriorRing().getNumPoints() * 3);
    for(int i = 0; i < polygon.getNumInteriorRing(); i++)
      str.append("-" + polygon.getInteriorRingN(i).getNumPoints() * 3);
    str.append(">");
    return str.toString();
  }

}
